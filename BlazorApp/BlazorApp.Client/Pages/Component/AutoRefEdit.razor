@typeparam TRef where TRef : BaseRef, new()
@using System.Reflection
@using System.ComponentModel.DataAnnotations
@using ClassLibrary.Models

@inject HttpClient Http
@inject NavigationManager NavManager

@if (Model == null || _loading || _editContext is null)
{
    <p>Загрузка...</p>
}
else
{
    @if (!string.IsNullOrWhiteSpace(_serverError))
    {
        <div class="alert alert-danger">@_serverError</div>
    }

    <EditForm EditContext="_editContext" OnSubmit="TrySaveAsync" FormName="@(ResolvedFormName)">
        <DataAnnotationsValidator />
        <ValidationSummary />

        @foreach (var prop in GetDisplayProps())
        {
            <div class="mb-2">
                <label class="form-label">@GetDisplayName(prop)</label>

                @if (prop.PropertyType == typeof(string))
                {
                    <input class="form-control"
                           value="@GetString(prop)"
                           @oninput="@(e => SetString(prop, e.Value?.ToString()))" />
                }
                else if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(int?))
                {
                    <input type="number" class="form-control"
                           value="@GetIntString(prop)"
                           @oninput="@(e => SetInt(prop, e.Value))" />
                }
                else if (typeof(BaseRef).IsAssignableFrom(prop.PropertyType) && prop.PropertyType != typeof(TRef))
                {
                    if (ReferenceDictionaries is not null && ReferenceDictionaries.TryGetValue(prop.PropertyType, out var options))
                    {
                        <select class="form-select" @onchange="@(e => SetReference(prop, e.Value))">
                            <option value="">— выберите —</option>
                            @foreach (var opt in options)
                            {
                                var refObj = (BaseRef)opt;
                                <option value="@refObj.Id" selected="@(GetReferenceId(prop) == refObj.Id)">
                                    @refObj.Name
                                </option>
                            }
                        </select>
                    }
                    else
                    {
                        <div class="text-muted small">Нет данных для выбора (@prop.PropertyType.Name)</div>
                    }
                }
                else
                {
                    <input class="form-control"
                           value="@GetString(prop)"
                           @oninput="@(e => SetString(prop, e.Value?.ToString()))" />
                }
            </div>
        }

        <div class="mt-3">
            <button class="btn btn-success me-2" type="submit" disabled="@_saving">
                @(_saving ? "Сохранение..." : "Сохранить")
            </button>
            @if (ExtraButtons is not null)
            {
                @ExtraButtons
            }
        </div>
    </EditForm>
}

@code {
    // --- ПАРАМЕТРЫ ---
    [Parameter] public int Id { get; set; }
    [Parameter] public string ApiPath { get; set; } = default!; // "Resources", "Clients", ...
    [Parameter] public string? FormName { get; set; }

    // куда перейти после успеха (например, "/Resource"), если null — не переходим
    [Parameter] public string? NavigateOnSuccessTo { get; set; }

    // выпадающие справочники
    [Parameter] public Dictionary<Type, IEnumerable<BaseRef>>? ReferenceDictionaries { get; set; }

    // необязательные кастомные загрузчик/сохранение
    [Parameter] public Func<HttpClient, int, Task<TRef>>? Loader { get; set; }
    [Parameter] public Func<HttpClient, TRef, int, Task>? Saver { get; set; }

    [Parameter] public EventCallback<TRef> OnSaved { get; set; }
    [Parameter] public RenderFragment? ExtraButtons { get; set; }

    protected TRef? Model;
    bool _loading = true;
    bool _saving = false;
    string? _serverError;

    EditContext? _editContext;
    ValidationMessageStore? _messages;

    string ResolvedFormName => !string.IsNullOrWhiteSpace(FormName)
        ? FormName!
        : $"auto-edit-{typeof(TRef).Name.ToLowerInvariant()}";

    // --- LIFECYCLE ---
    protected override async Task OnParametersSetAsync()
    {
        _loading = true;
        _serverError = null;

        Model = Loader is not null
            ? await Loader(Http, Id)
            : await Http.GetFromJsonAsync<TRef>($"{ApiPath}/{Id}");

        _editContext = Model is null ? null : new EditContext(Model);
        if (_editContext is not null)
            _messages = new ValidationMessageStore(_editContext);

        _loading = false;
    }

    // --- SUBMIT/VALIDATION ---
    async Task TrySaveAsync(EditContext ctx)
    {
        if (Model is null || _editContext is null || _messages is null) return;

        _serverError = null;
        _messages.Clear();

        // 1) Валидируем DataAnnotations (если есть на моделях)
        bool daOk = ctx.Validate();

        // 2) Наша «обязательность всех полей»
        bool requiredOk = ValidateRequired();

        if (!(daOk && requiredOk))
        {
            _editContext.NotifyValidationStateChanged();
            return;
        }

        // 3) Сохранение + обработка ответа сервера (конфликт уникальности и т.д.)
        await SaveCoreAsync();
    }

    bool ValidateRequired()
    {
        if (_editContext is null || _messages is null || Model is null) return false;

        bool ok = true;

        foreach (var p in GetDisplayProps())
        {
            var fi = new FieldIdentifier(Model, p.Name);
            var val = p.GetValue(Model);

            // строки — не пустые/не пробелы
            if (p.PropertyType == typeof(string))
            {
                if (string.IsNullOrWhiteSpace(val as string))
                {
                    _messages.Add(fi, "Поле обязательно для заполнения.");
                    ok = false;
                }
                continue;
            }

            // int / int?
            if (p.PropertyType == typeof(int) || p.PropertyType == typeof(int?))
            {
                // считаем обязательным и не нулевым
                if (val is null)
                {
                    _messages.Add(fi, "Значение обязательно.");
                    ok = false;
                }
                else
                {
                    int iv = Convert.ToInt32(val);
                    if (iv == 0)
                    {
                        _messages.Add(fi, "Значение должно быть больше 0.");
                        ok = false;
                    }
                }
                continue;
            }

            // ссылки на BaseRef (другие справочники) — должны быть выбраны
            if (typeof(BaseRef).IsAssignableFrom(p.PropertyType) && p.PropertyType != typeof(TRef))
            {
                if (val is not BaseRef br || br.Id <= 0)
                {
                    _messages.Add(fi, "Необходимо выбрать значение.");
                    ok = false;
                }
                continue;
            }

            // для прочих типов — просто не null
            if (val is null)
            {
                _messages.Add(fi, "Поле обязательно для заполнения.");
                ok = false;
            }
        }

        return ok;
    }

    async Task SaveCoreAsync()
    {
        if (Model is null) return;

        _saving = true;
        HttpResponseMessage? resp = null;

        try
        {
            if (Saver is not null)
            {
                // Кастомный сохранитель: оборачиваем, чтобы ловить ошибки
                try
                {
                    await Saver(Http, Model, Id);
                    await OnSaveSuccess();
                    return;
                }
                catch (HttpRequestException ex)
                {
                    _serverError = ex.Message;
                    return;
                }
            }

            // По-умолчанию: POST для создания, PUT для обновления
            if (Id == 0)
                resp = await Http.PostAsJsonAsync($"{ApiPath}", Model);
            else
                resp = await Http.PutAsJsonAsync($"{ApiPath}/{Id}", Model);

            if (resp.IsSuccessStatusCode)
            {
                await OnSaveSuccess();
            }
            else
            {
                // читаем текст ошибки как есть (например, при нарушении уникальности)
                _serverError = await resp.Content.ReadAsStringAsync();
            }
        }
        finally
        {
            _saving = false;
        }
    }

    async Task OnSaveSuccess()
    {
        _serverError = null;
        await OnSaved.InvokeAsync(Model!);

        // навигация как в вашем фрагменте:
        if (!string.IsNullOrWhiteSpace(NavigateOnSuccessTo))
            NavManager.NavigateTo(NavigateOnSuccessTo);
    }

    // --- REFLECTION HELPERS ---
    List<PropertyInfo> GetDisplayProps() =>
        typeof(TRef).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.Name != nameof(BaseRef.Id))
        .Where(ShouldGenerate)
        .ToList();

    bool ShouldGenerate(PropertyInfo p)
    {
        var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
        if (scaffold is not null && scaffold.Scaffold == false) return false;

        var display = p.GetCustomAttribute<DisplayAttribute>();
        if (display?.GetAutoGenerateField() == false) return false;

        return true;
    }

    string GetDisplayName(PropertyInfo p)
    {
        var d = p.GetCustomAttribute<DisplayAttribute>();
        return d?.Name ?? p.Name;
    }

    string GetString(PropertyInfo p) => p.GetValue(Model!)?.ToString() ?? string.Empty;

    string? GetIntString(PropertyInfo p) => p.GetValue(Model!)?.ToString();

    void SetString(PropertyInfo p, string? v) => p.SetValue(Model!, v);

    void SetInt(PropertyInfo p, object? raw)
    {
        if (raw is null) { p.SetValue(Model!, null); return; }
        var s = raw.ToString();
        if (string.IsNullOrWhiteSpace(s)) { p.SetValue(Model!, null); return; }
        if (int.TryParse(s, out var i)) p.SetValue(Model!, i);
    }

    int? GetReferenceId(PropertyInfo p)
    {
        var refVal = p.GetValue(Model!) as BaseRef;
        return refVal?.Id;
    }

    void SetReference(PropertyInfo p, object? raw)
    {
        if (raw is null || ReferenceDictionaries is null) { p.SetValue(Model!, null); return; }
        if (!int.TryParse(raw.ToString(), out var id)) { p.SetValue(Model!, null); return; }
        if (!ReferenceDictionaries.TryGetValue(p.PropertyType, out var options)) { p.SetValue(Model!, null); return; }

        var selected = options.FirstOrDefault(x => x.Id == id);
        p.SetValue(Model!, selected);
    }
}
