@typeparam TRef where TRef : BaseRef, new()
@using System.Reflection
@using System.ComponentModel.DataAnnotations
@using ClassLibrary.Models

@inject HttpClient Http

@if (Model == null || _loading)
{
    <p>Загрузка...</p>
}
else
{
    <!-- Если хочешь нативный <form>, раскомментируй и используй @formname -->
    <!--
    <form method="post" @formname="ResolvedFormName" @onsubmit="HandleSubmit">
        ... твой контент ...
    </form>
    -->

    <EditForm Model="Model"
              OnValidSubmit="SaveAsync"
              FormName="@(ResolvedFormName)">
        <DataAnnotationsValidator />
        <ValidationSummary />

        @foreach (var prop in GetDisplayProps())
        {
            <div class="mb-2">
                <label class="form-label">@GetDisplayName(prop)</label>

                @if (prop.PropertyType == typeof(string))
                {
                    <input class="form-control"
                           value="@GetString(prop)"
                           @oninput="@(e => SetString(prop, e.Value?.ToString()))" />
                }
                else if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(int?))
                {
                    <input type="number" class="form-control"
                           value="@GetIntString(prop)"
                           @oninput="@(e => SetInt(prop, e.Value))" />
                }
                else if (typeof(BaseRef).IsAssignableFrom(prop.PropertyType) && prop.PropertyType != typeof(TRef))
                {
                    if (ReferenceDictionaries is not null && ReferenceDictionaries.TryGetValue(prop.PropertyType, out var options))
                    {
                        <select class="form-select" @onchange="@(e => SetReference(prop, e.Value))">
                            <option value="">— выберите —</option>
                            @foreach (var opt in options)
                            {
                                var refObj = (BaseRef)opt;
                                <option value="@refObj.Id" selected="@(GetReferenceId(prop) == refObj.Id)">
                                    @refObj.Name
                                </option>
                            }
                        </select>
                    }
                    else
                    {
                        <div class="text-muted small">Нет данных для выбора (@prop.PropertyType.Name)</div>
                    }
                }
                else
                {
                    <input class="form-control"
                           value="@GetString(prop)"
                           @oninput="@(e => SetString(prop, e.Value?.ToString()))" />
                }
            </div>
        }

        <div class="mt-3">
            <button class="btn btn-success me-2" type="submit">Сохранить</button>
            @if (ExtraButtons is not null)
            {
                @ExtraButtons
            }
        </div>
    </EditForm>
}

@code {
    // --- ПАРАМЕТРЫ ---
    [Parameter] public int Id { get; set; }
    [Parameter] public string ApiPath { get; set; } = default!; // "Resources", "Clients", ...
    [Parameter] public string? FormName { get; set; } // если не задан — сгенерируем

    // Справочники для выпадающих списков: typeof(Condition) => IEnumerable<Condition>, и т.п.
    [Parameter] public Dictionary<Type, IEnumerable<BaseRef>>? ReferenceDictionaries { get; set; }

    // Кастомные загрузчик/сохранение (необязательно)
    [Parameter] public Func<HttpClient, int, Task<TRef>>? Loader { get; set; }
    [Parameter] public Func<HttpClient, TRef, int, Task>? Saver { get; set; }

    // Коллбек после сохранения
    [Parameter] public EventCallback<TRef> OnSaved { get; set; }

    // Доп. кнопки (например, "В архив")
    [Parameter] public RenderFragment? ExtraButtons { get; set; }

    protected TRef? Model;
    bool _loading = true;
    string ResolvedFormName => !string.IsNullOrWhiteSpace(FormName)
        ? FormName!
        : $"auto-edit-{typeof(TRef).Name.ToLowerInvariant()}";

    // --- LIFECYCLE ---
    protected override async Task OnParametersSetAsync()
    {
        _loading = true;
        Model = Loader is not null
            ? await Loader(Http, Id)
            : await Http.GetFromJsonAsync<TRef>($"{ApiPath}/{Id}");
        _loading = false;
    }

    // --- SUBMIT ---
    async Task SaveAsync()
    {
        if (Model is null) return;

        if (Saver is not null)
            await Saver(Http, Model, Id);
        else
            await Http.PutAsJsonAsync($"{ApiPath}/{Id}", Model);

        await OnSaved.InvokeAsync(Model);
    }

    // Если используешь <form @formname> вариант:
    Task HandleSubmit() => SaveAsync();

    // --- REFLECTION HELPERS ---
    List<PropertyInfo> GetDisplayProps() =>
        typeof(TRef).GetProperties(BindingFlags.Public | BindingFlags.Instance)
        .Where(p => p.Name != nameof(BaseRef.Id))
        .Where(ShouldGenerate)
        .ToList();

    bool ShouldGenerate(PropertyInfo p)
    {
        var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
        if (scaffold is not null && scaffold.Scaffold == false) return false;

        var display = p.GetCustomAttribute<DisplayAttribute>();
        if (display?.GetAutoGenerateField() == false) return false;

        return true;
    }

    string GetDisplayName(PropertyInfo p)
    {
        var d = p.GetCustomAttribute<DisplayAttribute>();
        return d?.Name ?? p.Name;
    }

    string GetString(PropertyInfo p) => p.GetValue(Model!)?.ToString() ?? string.Empty;

    string? GetIntString(PropertyInfo p) => p.GetValue(Model!)?.ToString();

    void SetString(PropertyInfo p, string? v) => p.SetValue(Model!, v);

    void SetInt(PropertyInfo p, object? raw)
    {
        if (raw is null) { p.SetValue(Model!, null); return; }
        var s = raw.ToString();
        if (string.IsNullOrWhiteSpace(s)) { p.SetValue(Model!, null); return; }
        if (int.TryParse(s, out var i)) p.SetValue(Model!, i);
    }

    int? GetReferenceId(PropertyInfo p)
    {
        var refVal = p.GetValue(Model!) as BaseRef;
        return refVal?.Id;
    }

    void SetReference(PropertyInfo p, object? raw)
    {
        if (raw is null || ReferenceDictionaries is null) { p.SetValue(Model!, null); return; }
        if (!int.TryParse(raw.ToString(), out var id)) { p.SetValue(Model!, null); return; }
        if (!ReferenceDictionaries.TryGetValue(p.PropertyType, out var options)) { p.SetValue(Model!, null); return; }

        var selected = options.FirstOrDefault(x => x.Id == id);
        p.SetValue(Model!, selected);
    }
}
